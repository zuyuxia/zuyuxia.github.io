<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Write Code">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Write Code">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Write Code">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Write Code</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Write Code</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Talk is cheap , show me the code</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/20/虚拟内存/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/20/虚拟内存/" itemprop="url">内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-20T15:54:28+08:00">
                2018-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#内存管理</p>
<ol>
<li><p>虚拟内存</p>
<blockquote>
<ul>
<li>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如RAM）的使用也更有效率<br>引自维基百科：<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener">虚拟内存</a></li>
</ul>
</blockquote>
<ul>
<li><p>作用：</p>
<ul>
<li><p>无需在作业运行时一次性地装入内存，允许分成多次调入内存运行  </p>
</li>
<li><p>无需在作业运行时一直常驻内存</p>
</li>
<li><p>从逻辑上扩充内存的容量，是用户看到的内存容量</p>
</li>
</ul>
</li>
<li><p>虚拟内存的实现：请求分页存储管理；请求分段存储管理；请求段页式管理</p>
<ul>
<li>所需的硬件支持：一定容量的内存和外存；页表机制或段表机制；中断机构；地址变化机构</li>
</ul>
</li>
</ul>
</li>
<li><p>内存池的作用</p>
<ul>
<li><p>在C和C++语言中，经常需要动态分配内存，直接调用malloc/free、new/delete会有以下弊端：频繁调用会产生大量内存碎片，大大降低内存的使用效率</p>
</li>
<li><p>内存池技术能够减少内存碎片，提高内存的分配效率</p>
</li>
</ul>
</li>
<li><p>内存池的实现原理</p>
<blockquote>
<ul>
<li>先调用new/malloc函数申请一大块内存，然后维护一个空闲链表，该链表是一个个小的空闲内存片，每当需要内存时就从空闲链表上拿过来一个小片内存使用。如果空闲链表为空了，就从之前分配的大块内存去取几个插入到空闲链表上。如果分配的大块内存也用光了，就继续用new/malloc申请一大块</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>引用资料：<a href="https://github.com/oscarwin/MemoryPool" target="_blank" rel="noopener">MemoryPool</a></li>
</ul>
</blockquote>
<ul>
<li>关于内存池的博客：<ul>
<li><a href="http://blog.csdn.net/k346k346/article/details/49538975" target="_blank" rel="noopener">内存池介绍与经典内存池的实现</a></li>
</ul>
</li>
</ul>
</li>
<li><p>STL里内存池如何实现</p>
<ul>
<li><strong>待完善</strong></li>
</ul>
</li>
<li><p>Linux内存管理：用户空间和内核空间</p>
<ul>
<li><p>以4G进程地址空间为例，用户空间为0-3G，内核空间为3-4G；通常用户只能访问用户空间，进行系统调用时才能访问内核空间</p>
</li>
<li><p>用户空间对应进程，进程切换时用户空间也变化；内核空间由内核负责映射，并不会随进程变化而变化</p>
</li>
<li><p>用户空间：数据段，代码段，BSS端，堆，栈；内核空间：ZONE_DMA，ZONE_NORMAL，ZONE_HIGHMEM</p>
</li>
<li><p>参考博客：<a href="http://blog.csdn.net/yusiguyuan/article/details/12045255" target="_blank" rel="noopener">linux内存管理–用户空间和内核空间</a></p>
</li>
</ul>
</li>
<li><p>伙伴算法和slab算法</p>
<ul>
<li><p>伙伴算法和slab算法：管理内存碎片大小和管理内存碎片效率</p>
</li>
<li><p>伙伴算法：物理内存所有空闲页都记录在BUDDY链表之中，链表中的每个元素都带一类大小的内存，为2^n；对于每一类内存大小又有一个链表，表示当前可分配的物理内存；分配内存时，先从空闲内存中搜索比申请的内存大的最小内存块，若存在一块空闲内存刚好等于申请内存，则分配，若不存在，则将找到的大内存分为两部分，一部分分给申请内存，另一部分加入空闲内存块链表</p>
</li>
<li><p>slab算法：slab分配算法采用cache存储内核对象，起初包括若干空闲的对象，当需要内核数据结构的对象时，可以直接从cache上直接获取，并将对象初始化为使用</p>
</li>
<li><p>伙伴算法通常对于内存块单位较大的内存作用比较好，对于小块内存的分配和回收则采用slab算法</p>
</li>
<li><p>参考资料：</p>
<ul>
<li><a href="http://blog.csdn.net/wenqian1991/article/details/27968779" target="_blank" rel="noopener">【Linux 内核】内存管理（二）伙伴算法</a></li>
<li><a href="http://blog.csdn.net/u013009575/article/details/17751147" target="_blank" rel="noopener">内存分配—–伙伴算法和slab算法</a></li>
<li><a href="http://blog.csdn.net/henzox/article/details/42458923" target="_blank" rel="noopener">Slab 算法</a></li>
</ul>
</li>
</ul>
</li>
<li><p>高端内存</p>
<ul>
<li><p>高端内存值物理地址大于896M的内存，对于这样的内存，无法在“内核直接映射空间”进行映射；引入高端内存的主要原因在于内核的1G线性地址空间无法建立一个完全的直接映射来访问整个物理内存空间</p>
</li>
<li><p>ZONE_HIGHMEM：896M~结束</p>
</li>
<li><p>内核能够借助高端内存访问所有物理内存：当内核想要访问物理地址高于896M的内存时，会从高端内存区借一段地址空间，建立临时地址映射，使用完毕后释放</p>
</li>
<li><p>参考资料：</p>
<ul>
<li><a href="https://github.com/gatieme/LDD-LinuxDeviceDrivers/blob/master/study/kernel/02-memory/01-description/05-highmem/README.md" target="_blank" rel="noopener">服务器体系与共享存储器架构</a></li>
<li><a href="http://blog.csdn.net/vanbreaker/article/details/7579941" target="_blank" rel="noopener">Linux高端内存映射(上)</a></li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/epoll详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/epoll详解/" itemprop="url">epoll详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T21:25:42+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/select-poll-epoll/" itemprop="url" rel="index">
                    <span itemprop="name">select/poll/epoll</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#epoll详解<br>为了解决select/poll的缺点，自从Linux内核2.5.44版本引进了epoll API，epoll已经成为了目前实现高性能网络服务器的必备技术</p>
<ol>
<li><p>epoll相关函数  </p>
<pre><code>int epoll_create(int size);
int epoll_create1(int flags);  
参数：
    size：自从Linux 2.6.8之后，size参数就被忽略掉了，但是必须比0大
    flags：可以设置为EPOLL_CLOEXEC，代表结束后自动关闭epollfd句柄  
返回值：
    -1：出错，errno被设置成相应值
    非负值：返回一个epoll句柄

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
参数：
    epfd：epoll_create返回的句柄
    op：动作，有三种取值EPOLL_CTL_ADD、EPOLL_CTL_MOD、EPOLL_CTL_DEL
    fd：需要监听的文件描述符
    event：告诉内核监听fd上面的什么事件  
返回值：
    -1：出错，errno被设置成相应值
     0：成功
epoll_event结构体：
    typedef union epoll_data {
       void        *ptr;
       int          fd;
       uint32_t     u32;
       uint64_t     u64;
    } epoll_data_t;

    struct epoll_event {
       uint32_t     events;      /* Epoll events */
       epoll_data_t data;        /* User data variable */
    };
    epoll_event中的events有以下取值：
        EPOLLIN ：表示对应的文件描述符可以读
        EPOLLOUT：表示对应的文件描述符可以写
        EPOLLPRI：表示对应的文件描述符有紧急的数据可读
        EPOLLERR：表示对应的文件描述符发生错误
        EPOLLHUP：表示对应的文件描述符被挂断
        EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，默认为LT模式
        EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
参数：
    epfd：epoll_create返回的句柄
    events：存放监听到的就绪事件
    maxevents：说明events的数组有多大
    timeout：超时时间，单位是毫秒  
返回值：
    -1：出错，errno被设置成相应值
     0：超时，没有文件描述符准备就绪
     正值：就绪的文件描述符的个数
</code></pre></li>
</ol>
<ol>
<li><p>为什么epoll能够高速处理大并发连接</p>
<blockquote>
<ul>
<li>使用epoll的基本过程：调用epoll_create创建一个epollfd句柄 -调用epoll_ctl加入想要监测的fd -调用epoll_wait，在给定的超时时间内，返回监测到就绪的events</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>select/poll在被调用时，都需要将所有的要监测的fd从用户态copy到内核态，这样的操作非常低效；而epoll则在调用epoll_ctl时就已经向内核中添加了需要监测的fd</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>epoll在被内核初始化时，就会开辟出epoll的<strong>内核高速cache区</strong>，注册了一个文件系统，用于放置我们想要监测的文件描述符；在调用epoll_create时，在这个虚拟的epoll文件系统里创建一个file结点；调用epoll_ctl时，被监测的文件描述符被放到epoll文件系统中，组织成<strong>红黑树</strong>的形式，保存在内核cache中，能够快速的查找、插入和删除，此外还会给内核中断处理程序注册一个回调函数；还会建立一个<strong>list链表</strong>，用于存储准备就绪的事件，调用epoll_wait时，仅仅看这个链表中有没有数据 </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>内核高速cache区就是建立连续的物理内存页，在这之上建立slab层；简单说就是在物理上分配好你想要的大小的内存对象，每次使用时都是使用空闲的已分配好的对象</li>
</ul>
</blockquote>
<ul>
<li><p>引自博客：<a href="https://www.jianshu.com/p/b5bc204da984" target="_blank" rel="noopener">linux下非阻塞io库 epoll</a></p>
</li>
<li><p>epoll中<strong>并未使用共享内存（mmap）</strong>的技术，在许多博客中都提到了epoll使用了共享内存的技术。然而有位同学读了epoll源码反驳了这种说法：  </p>
<ul>
<li>参考资料：<a href="https://www.nowcoder.com/discuss/26226" target="_blank" rel="noopener">epoll内核源码详解+自己总结的流程</a></li>
</ul>
</li>
<li><p>epoll中从内核态拷贝到用户态代码是__put_user这个函数</p>
</li>
</ul>
</li>
<li><p>工作模式</p>
<ul>
<li><p>LT：水平触发模式，默认模式。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>
</li>
<li><p>ET：边缘触发模式，高速模式。当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
</li>
<li><p>由此可见，ET高速模式大大的减少了epoll事件被重复触发的次数。epoll在ET模式下只能使用非阻塞套接字，避免由于某一个套接字的阻塞读/写把多个处理文件描述符的任务饿死。epoll在LT模式下即可用阻塞也可用非阻塞套接字</p>
</li>
</ul>
</li>
<li><p>附录：一些好的参考博文  </p>
<ul>
<li><p><a href="http://www.cnblogs.com/lojunren/p/3856290.html" target="_blank" rel="noopener">Linux下的I/O复用与epoll详解</a></p>
</li>
<li><p><a href="http://www.cnblogs.com/Anker/archive/2013/08/17/3263780.html" target="_blank" rel="noopener">IO多路复用之epoll总结</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000003063859#articleHeader17" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p>
</li>
<li><p><a href="http://blog.csdn.net/xiajun07061225/article/details/9250579" target="_blank" rel="noopener">【Linux学习】epoll详解</a></p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/poll详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/poll详解/" itemprop="url">poll详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T21:25:34+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/select-poll-epoll/" itemprop="url" rel="index">
                    <span itemprop="name">select/poll/epoll</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#poll详解<br>poll和select机制类似，管理多个描述符也是进行轮询，根据描述符的状态进行处理。但是poll没有最大文件描述符数量的限制</p>
<ol>
<li><p>poll函数  </p>
<pre><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);  
参数：
    fds：存放需要被检测事件的socket描述符的结构数组
    nfds：数组fds中元素的数量  
    timeout：超时时间，单位是毫秒
返回值：
    -1：出错，errno被设置成相应值
    0：超时，没有任何描述符就绪
    正值：就绪描述符的个数，即revents成员值非0的描述符个数
</code></pre><ul>
<li><p>参数timeout：指定poll函数返回前等待多长时间，它是一个指定应等待毫秒数的正值</p>
<ul>
<li><p>INFTIM：永远等，直到有一个描述符准备好I/O才返回</p>
</li>
<li><p>0：根本不等待，不阻塞进程</p>
</li>
<li><p>>0：等待指定时间  </p>
</li>
</ul>
</li>
<li><p>nfds:数组fds中的元素个数</p>
</li>
<li><p>fds：待测试描述符的最大值+1</p>
<pre><code>pollfd结构体：
struct pollfd{    
    int fd;
    short events;  
    short revents;  
};
</code></pre></li>
</ul>
</li>
<li><p>events标志</p>
<ul>
<li><p>POLLIN                有数据可读</p>
</li>
<li><p>POLLRDNORM            有普通数据可读</p>
</li>
<li><p>POLLRDBAND            有优先数据可读</p>
</li>
<li><p>POLLPRI                有紧迫数据可读</p>
</li>
<li><p>POLLOUT                写数据不会导致阻塞</p>
</li>
<li><p>POLLWRNORM            写普通数据不会导致阻塞</p>
</li>
<li><p>POLLWRBAND            写优先数据不会导致阻塞</p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p>revents除了上述值之外还有以下几种</p>
<ul>
<li><p>POLLER        指定的文件描述符发生错误</p>
</li>
<li><p>POLLHUP        指定的文件描述符挂起事件</p>
</li>
<li><p>POLLNVAL        指定的文件描述符非法</p>
</li>
</ul>
</li>
<li><p>fd为负值时poll函数的处理</p>
<ul>
<li>poll函数将忽略这样的pollfd结构的events成员，返回时将它的revents成员的值置为0</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/select详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/select详解/" itemprop="url">select详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T21:19:22+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/select-poll-epoll/" itemprop="url" rel="index">
                    <span itemprop="name">select/poll/epoll</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="select详解"><a href="#select详解" class="headerlink" title="select详解"></a>select详解</h1><blockquote>
<p>select函数允许进程指示内核等待多个事件中的任何一个发生，并只在一个、多个时间发生或经历一段时间后才唤醒它</p>
</blockquote>
<ol>
<li><p>select函数  </p>
<pre><code>int select( int nfds , fd_set *readfds , fd_set *writefds , fd_set *exceptfds ,struct timeval *timeout );  
参数：
    nfds：读、写、异常集合中文件描述符的最大值+1  
    readfds：读集合  
    writefds：写集合  
    exceptfds：异常集合  
    timeout：超时结构体
返回值：
    -1：出错，errno被设置成相应值
    0：超时，没有任何描述符就绪
    正值：所有描述符集的已就绪的描述符的个数

四种操作fd_set的宏
void FD_CLR(int fd, fd_set *set);
int  FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
</code></pre><ul>
<li><p>参数timeout：告知内核等待所指定描述符中的任何一个就绪可花多长时间，有三种取值可能</p>
<ul>
<li>NULL：永远等，直到有一个描述符准备好I/O才返回</li>
<li>0：根本不等待，检查描述符后立即返回，称为轮询（timeval结构体中的值为0）</li>
<li><p>等待一段时间：在有一个描述符准备好I/O时返回，但是不超过设定时间  </p>
<pre><code>timeval结构体：
struct timeval{    
    long tv_sec;  
    long tv_usec;  
};
</code></pre></li>
</ul>
</li>
<li><p>readfds,writefds,exceptfds</p>
<ul>
<li>fd_set的数据类型的可能实现之一：通常是一个整数数组，每个整数的每一位对应一个描述符</li>
<li>描述符集必须初始化</li>
<li>若对某一个不感兴趣，设为NULL</li>
</ul>
</li>
<li><p>nfds：待测试描述符的最大值+1</p>
</li>
</ul>
</li>
<li><p>FD_SETSIZE</p>
<ul>
<li>是fd_set中的描述符总数，通常是1024</li>
<li>通过改变FD_SETSIZE再重新编译内核，能够增大FD_SETSIZE</li>
</ul>
</li>
<li><p>描述符就绪条件</p>
<blockquote>
<ul>
<li>套接字可读<br>（1）该套接字的接收缓冲区中的数据字节数大于等于套接字接收缓冲区低水位标记的当前大小，对这样的套接字执行读操作不会阻塞并返回一个大于0的值（也就是返回准备好读入的数据）<br>（2）该连接的读半部关闭（也就是接收了FIN包的TCP连接）；对这样的套接字的读操作将不阻塞并返回0（即EOF）<br>（3）该套接字是监听套接字且已完成连接数不为0；对这样的套接字，accept通常不会阻塞<br>（4）其上有一个套接字错误待处理；对这样的套接字的读操作将不阻塞，直接返回-1并将errno设置成确切的错误条件  </li>
</ul>
</blockquote>
</li>
</ol>
<blockquote>
<ul>
<li>套接字可写<br>   （1）该套接字的发送缓冲区中的可用空间字节数大于等于套接字发送缓冲区低水位标记的当前大小，并且或者该套接字已连接，或者该套接字不需要连接；如果把这样的套接字设置为非阻塞的，写操作将不阻塞并返回一个正值<br>   （2）该连接的写半部关闭；对这样的套接字进行写操作将产生SIGPIPE信号<br>   （3）其上有一个套接字错误待处理；对这样的套接字的读操作将不阻塞，直接返回-1并将errno设置成确切的错误条件  </li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>异常<br>   套接字存在带外数据</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/虚函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/虚函数/" itemprop="url">虚函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T12:38:03+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>#虚函数</p>
<ul>
<li><p>虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）和虚表指针来实现的。在这个表中，主要是一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。如果派生类覆写了基类的虚函数，那么对于派生类的虚函数，就会将对应的虚函数替换为派生类的虚函数地址</p>
</li>
<li><p>编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的每个虚函数占据虚函数表中的一块；在有虚函数的类的实例中分配了指向这个表的指针的内存(虚表指针)</p>
</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2018/03/17/虚函数/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/TCP-UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/TCP-UDP/" itemprop="url">TCP/UDP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T22:47:17+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#TCP/UDP</p>
<ol>
<li><p>ISO七层模型</p>
<ul>
<li><p>表示层功能：图像、视频编码解码，数据加密解密</p>
</li>
<li><p>会话层：建立会话，管理会话</p>
</li>
</ul>
</li>
<li><p>TCP头部的标志位</p>
<ul>
<li><p>URG：标志紧急指针是否有效</p>
</li>
<li><p>ACK：标志确认号是否有效（确认报文段），解决丢包问题</p>
</li>
<li><p>PSH：提示接收端立即从缓冲读走数据</p>
</li>
<li><p>RST：表示要求对方重新建立连接（复位报文段）</p>
</li>
<li><p>SYN：表示请求建立一个连接（连接报文段）</p>
</li>
<li><p>FIN：表示关闭连接（断开报文段）</p>
</li>
</ul>
</li>
<li><p>三次握手</p>
<ul>
<li><p>first，客户机发送SYN位，SEQ_NUM = S的包到服务器（客户机处于SYN_SEND状态）</p>
</li>
<li><p>second，服务器发送ACK、SYN位，且ACK_NUM = S+1，SEQ_NUM = P的包到客户机（服务器处于SYN_RECV状态）</p>
</li>
<li><p>third，客户机发送ACK位，且ACK_NUM = P+1的包到服务器（客户机处于ESTABLISH状态，服务器处于ESTABLISH状态）</p>
</li>
</ul>
</li>
<li><p>四次挥手</p>
<ul>
<li><p>first，客户机发送FIN位，SEQ_NUM = Q的包到服务器（客户机处于FIN_WAIT_1状态）</p>
</li>
<li><p>second，服务器发送ACK位，且ACK_NUM = Q+1的包到服务器（服务器处于CLOSE_WAIT状态，客户机处于FIN_WAIT_2状态）</p>
</li>
<li><p>客户到服务器连接断开，但服务器到客户连接还未断开，此处有等待</p>
</li>
<li><p>third，服务器发送FIN位，且SEQ_NUM = R的包到客户机（服务器处于LAST_ACK状态，客户机处于TIME_WAIT状态）</p>
</li>
<li><p>此处有等待</p>
</li>
<li><p>fourth，客户机发送最后一个含有ACK位，且ACK_NUM = R+1的包到服务器（服务器处于CLOSED状态）</p>
</li>
</ul>
</li>
<li><p>为什么握手是三次，挥手是四次</p>
<ul>
<li><p>对于握手，只需要确定双方通信时的初始化序号，保证通信不会乱序</p>
</li>
<li><p>第三次握手的原因：假如第二次握手失败，那么客户机就会超时重发连接请求，而服务器对客户机已经有了一个连接。这会造成服务器对客户有多个连接，造成资源的浪费</p>
</li>
<li><p>对于挥手，TCP是双工的，发送双方都需要FIN和ACK</p>
</li>
</ul>
</li>
<li><p>TCP的连接状态</p>
<ul>
<li>CLOSED</li>
<li>LISTEN</li>
<li>SYN_SEND</li>
<li>SYN_RECV</li>
<li>ESTABLISH</li>
<li>FIN_WAIT_1</li>
<li>CLOSE_WAIT</li>
<li>FIN_WAIT_2</li>
<li>LAST_ACK</li>
<li>TIME_WAIT</li>
</ul>
</li>
<li><p>超时重传</p>
<ul>
<li><p>发送端发送报文后若长时间未收到确认的报文则需要重发该报文</p>
</li>
<li><p>可能的情况：发送的数据未到达接收端；接收端接收到数据，但ACK报文返回过程中丢失；接收端拒绝或者丢弃数据</p>
</li>
</ul>
</li>
<li><p>RTO（重传间隔）</p>
<ul>
<li><p>从上一次发送数据，到下一次重发之间的时间</p>
</li>
<li><p>通常是前一次重传间隔的两倍；重传次数到达上限后停止重传</p>
</li>
</ul>
</li>
<li><p>RTT</p>
<ul>
<li><p>数据从发送到接收到对方响应之间的时间间隔</p>
</li>
<li><p>这个数据往往不稳定</p>
</li>
</ul>
</li>
<li><p>流量控制原理（点对点）</p>
<ul>
<li><p>接收方通过TCP头部中的窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题 </p>
</li>
<li><p>发送窗：限制发送方可以发送的数据大小</p>
</li>
<li><p>接收窗：标记可以接收的数据大小</p>
</li>
<li><p>发送窗内的数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据；接收窗只有接收到数据且最左侧连续时才移动接收窗口</p>
</li>
</ul>
</li>
<li><p>拥塞控制（网络链路全局）</p>
<ul>
<li><p>防止数据过多注入网络中导致网络资源过载</p>
</li>
<li><p>TCP拥塞控制算法：慢开始 &amp; 拥塞控制；快速重传 &amp; 快速恢复</p>
</li>
</ul>
</li>
<li><p>TCP的可靠数据传输如何保证</p>
<ul>
<li><p>建立连接</p>
</li>
<li><p>序号机制</p>
</li>
<li><p>数据校验</p>
</li>
<li><p>超时重传</p>
</li>
<li><p>窗口机制</p>
</li>
<li><p>拥塞控制</p>
</li>
</ul>
</li>
<li><p>TCP的socket交互流程</p>
<ul>
<li><p>服务器：socket -&gt; bind -&gt;listen -&gt; accept -&gt; read/write -&gt;close</p>
</li>
<li><p>客户端：socket -&gt; connect -&gt; write/read -&gt; close</p>
</li>
</ul>
</li>
<li><p>UDP</p>
<ul>
<li><p>UDP是一个非连接协议</p>
</li>
<li><p>UDP使用尽最大努力交付，即不保证可靠交付</p>
</li>
<li><p>UDP首部只要8个字节，开销小</p>
</li>
<li><p>UDP是面向报文的</p>
</li>
<li><p>UDP没有拥塞控制</p>
</li>
<li><p>UDP支持一对一、一对多、多对一以及多对多的交互通信</p>
</li>
</ul>
</li>
<li><p>TCP/UDP的场景应用</p>
<ul>
<li><p>TCP：SMTP、HTTP、FTP、TELNET</p>
</li>
<li><p>UDP：即时通信、DNS、DHCP、在线视频</p>
</li>
</ul>
</li>
<li><p>TCP粘包怎么处理</p>
<ul>
<li><p>加包头，包头中包含数据包长度</p>
</li>
<li><p>约定好数据包的固定长度，发送、接收固定长度的数据包</p>
</li>
<li><p>数据包之间设置边界，添加特殊符号</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/HTTP协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/HTTP协议/" itemprop="url">HTTP协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T22:46:57+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#HTTP</p>
<p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。Cookie和Session。</p>
<pre><code>* HTTP工作在应用层，其在传输层由TCP协议为其提供服务
</code></pre><ol>
<li><p>HTTP工作流程</p>
<ul>
<li><p>客户机和服务器建立连接</p>
</li>
<li><p>建立连接后，客户机向服务器发送请求</p>
</li>
<li><p>服务器收到请求并发送响应</p>
</li>
<li><p>客户机将返回的响应解析并呈现，断开连接</p>
</li>
</ul>
</li>
<li><p>Cookie</p>
<ul>
<li><p>Cookie是客户端保持状态的方法。</p>
</li>
<li><p>Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p>
</li>
</ul>
</li>
<li><p>HTTP的主要特点</p>
<ul>
<li><p>简单快速</p>
</li>
<li><p>灵活</p>
</li>
<li><p>无连接：限制每次连接只处理一个请求；服务器处理完请求并收到客户应答后，即断开连接（Keep-Alive支持长连接，解决无连接的问题）</p>
</li>
<li><p>无状态：协议对于事物的处理没有记忆能力；服务器在发送完数据后不会记录信息（cookie机制可以保持session，解决无状态的问题）</p>
</li>
</ul>
</li>
<li><p>HTTP1.1的特点</p>
<ul>
<li><p>默认持久连接，节省通信量，只要客户端、服务端任意其中一段没有提出断开连接，连接一直保持，可多次发送HTTP请求</p>
</li>
<li><p>管线化，客户端可同时发出多个HTTP请求，不用一个个等待响应</p>
</li>
<li><p>断点续传</p>
</li>
</ul>
</li>
<li><p>HTTP2.0的特点</p>
<ul>
<li><p>采用二进制格式而不是文本格式</p>
</li>
<li><p>多路复用，只需一个HTTP连接可实现多个请求响应</p>
</li>
<li><p>使用报头压缩，降低了开销</p>
</li>
<li><p>让服务器可以将响应主动推送到客户端的缓存中</p>
</li>
</ul>
</li>
<li><p>GET和POST的区别</p>
<ul>
<li><p>GET重点在从服务器上获取资源；POST重点在向服务器发送数据</p>
</li>
<li><p>GET传输数据是通过URL请求，以field = value的形式置于URL后，之间用 ？ 连接，多个请求数据间使用 &amp; 连接，用户可见；POST传输数据则是将字段与对应值封存在请求实体中发送给服务器，用户不可见</p>
</li>
<li><p>GET传输数据量小，受URL长度限制，效率高；POST传输数据量大，上传文件只能用POST</p>
</li>
<li><p>GET不安全，URL可见；POST比GET安全性高</p>
</li>
</ul>
</li>
<li><p>HTTP返回的状态码</p>
<ul>
<li><p>200：请求被正常处理</p>
</li>
<li><p>204：请求被受理但没有资源可以返回</p>
</li>
<li><p>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</p>
</li>
<li><p>301：永久性重定向</p>
</li>
<li><p>302：临时重定向</p>
</li>
<li><p>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</p>
</li>
<li><p>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</p>
</li>
<li><p>307：临时重定向，与302类似，只是强制要求使用POST方法</p>
</li>
<li><p>400：请求报文语法有误，服务器无法识别</p>
</li>
<li><p>401：请求需要认证</p>
</li>
<li><p>403：请求的对应资源禁止被访问</p>
</li>
<li><p>404：服务器无法找到对应资源</p>
</li>
<li><p>500：服务器内部错误</p>
</li>
<li><p>503：服务器正忙</p>
</li>
</ul>
</li>
<li><p>HTTP协议头部</p>
<ul>
<li><p>HTTP数据：请求行、首部字段、空行、报文主体</p>
</li>
<li><p>首部字段：通用首部字段、请求首部字段、响应首部字段、实体首部字段</p>
</li>
</ul>
</li>
<li><p>HTTPS与HTTP</p>
<ul>
<li><p>HTTPS在HTTP与传输层之间加上了一个SSL</p>
</li>
<li><p>对称加密与非对称加密</p>
</li>
</ul>
</li>
<li><p>浏览器中输入一个URL发送了什么</p>
<blockquote>
<ul>
<li>浏览器中输入URL，首先浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。</li>
<li>得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理。如果采用https还会先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。</li>
<li>引用自：<a href="https://www.nowcoder.com/discuss/59394" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/59394</a></li>
</ul>
</blockquote>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/select-poll-epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/select-poll-epoll/" itemprop="url">I/O多路复用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T16:56:38+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/select-poll-epoll/" itemprop="url" rel="index">
                    <span itemprop="name">select/poll/epoll</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#select/poll/epoll</p>
<blockquote>
<p>I/O复用使用在以下网络应用场合  </p>
<pre><code>* 当客户处理多个描述符时，必须使用I/O复用  
* 一个客户同时处理多个套接字  
* TCP服务器既要处理监听套接字，又要处理已连接套接字  
* 服务器既要处理TCP，又要处理UDP  
</code></pre><ul>
<li>服务器处理多个服务或者多个协议</li>
</ul>
</blockquote>
<ol>
<li><p>select/poll/epoll的区别</p>
<ul>
<li><p>操作方式及效率：select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。</p>
</li>
<li><p>最大连接数：select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。</p>
</li>
<li><p>fd拷贝：select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。</p>
</li>
<li><p>其他：select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。</p>
</li>
</ul>
</li>
<li><p>select</p>
<ul>
<li><a href="./select详解">select详解</a></li>
</ul>
</li>
<li><p>poll详解</p>
<ul>
<li><a href="./poll详解">poll详解</a></li>
</ul>
</li>
<li><p>epoll详解</p>
<ul>
<li><a href="./epoll详解">epoll详解</a></li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/进程间通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/进程间通信/" itemprop="url">进程间通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T16:55:31+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#进程间通信</p>
<pre><code>* 管道，消息队列，共享内存，信号量，套接字

* 管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系

* 信号量：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据

* 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识

* 共享内存：共享内存是最快的IPC。共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问

* 信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生
</code></pre><p>##共享内存的实现原理</p>
<ul>
<li><p>共享内存实现分为两种方式：一种采用mmap，一种采用system V机制的共享内存的方法</p>
</li>
<li><p>mmap是内存文件映射，将一个文件映射到两个不同进程的地址空间，可实现任意进程间的通信。mmap也可以采用匿名映射，不指定映射的文件，此时只能用于父子进程间通信</p>
</li>
<li><p>system V的共享内存实际上也是映射文件实现的，但是映射的是特殊的文件系统shm下的文件，文件系统shm安装点在交换分区上，系统重新引导后，所有的内容都丢失，该文件不能通过read或write访问</p>
</li>
<li><p>区别：</p>
<ul>
<li>system V共享内存中的数据，从不写入到实际磁盘中；通过mmap映射文件实现的共享内存可以指定什么时候将数据写入到磁盘文件中</li>
<li>system V共享内存是随内核持续的，即使访问共享内存的进程终止，共享内存区也存在（除非显式删除），在系统重新引导之前，对共享内存区的操作都将保留</li>
<li>通过调用mmap映射文件进行的通信，要注意考虑进程何时终止对通信产生的影响</li>
</ul>
</li>
</ul>
<h2 id="常见的信号"><a href="#常见的信号" class="headerlink" title="常见的信号"></a>常见的信号</h2><ul>
<li><p>SIGINT：程序终止信号</p>
</li>
<li><p>SIGKILL：用来立即结束程序运行，不能被阻塞、处理和忽略</p>
</li>
<li><p>SIGTERM：程序结束信号, 与SIGKILL不同的是该信号可以被阻塞和处理</p>
</li>
<li><p>SIGSEGV：试图访问未分配给自己的内存或向没有写权限的内存地址写数据</p>
</li>
<li><p>SIGCHLD：子进程结束时, 父进程会收到这个信号</p>
</li>
<li><p>SIGALRM：时钟定时信号</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/16/进程与线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zuyuxia">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/code.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Write Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/16/进程与线程/" itemprop="url">进程与线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-16T16:53:42+08:00">
                2018-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#进程</p>
<pre><code>* 基本概念：进程是资源分配的基本单位
* 进程结构组成：堆栈段、代码段、数据段
* PCB:各种数据、代码的地址或索引表地址
* 进程的调度实际上就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息
* 子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，若子进程相应运行自己的代码段，可以调用execv()函数重新加载新的代码段
</code></pre><ol>
<li><p>进程的创建与结束</p>
<ul>
<li><p>进程的创建方式：操作系统创建，父进程创建</p>
</li>
<li><p>接口：fork(); exit(int); getpid(); getppid();</p>
</li>
</ul>
</li>
<li><p>exit()与_exit()</p>
<ul>
<li><p>exit()是_exit()的封装，都会在终止进程并做相关收尾工作</p>
</li>
<li><p>exit会在调用_exit()函数前刷新数据流，而_exit()函数关闭全部描述符和清理函数后不会刷新流</p>
</li>
</ul>
</li>
<li><p>return和exit()</p>
<ul>
<li>exit()是函数，执行完后控制权交给系统；return在调用函数中，执行完后控制权交给调用进程，在main函数中，交给系统</li>
</ul>
</li>
<li><p>僵尸进程和孤儿进程</p>
<ul>
<li><p>父进程创建子进程后，以未知的顺序执行；若父进程先于子进程结束，子进程成为孤儿进程，自动向上被init进程收养，问题不大；若子进程先于父进程结束，父进程未调用wait()或waitpid()获取子进程信息，那么子进程描述符一直保存在系统中，称为孤儿进程</p>
</li>
<li><p>僵尸进程的危害：进程号一直被占用，系统所能使用的进程号是有限的，会导致没有可用的进程号</p>
</li>
<li><p>回收进程接口：wait()，waitpid()</p>
</li>
</ul>
</li>
<li><p>守护进程</p>
<ul>
<li><p>脱离终端并在后台运行的进程，执行中信息不显示在终端上也不会被终端发出的信号打断</p>
</li>
<li><p>操作步骤</p>
<ul>
<li><p>创建子进程，父进程退出</p>
</li>
<li><p>在子进程中创建新的会话</p>
</li>
<li><p>改变当前目录结构为根</p>
</li>
<li><p>重设文件掩码</p>
</li>
<li><p>关闭文件描述符</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>上下文切换</p>
<ul>
<li>内核管理所有进程控制块，进程控制块记录了进程全部状态信息，每一次进程调度就是上下文切换</li>
</ul>
</li>
<li><p>fork与vfork区别  </p>
<blockquote>
<ul>
<li>fork和vfork都用于创建子进程。但是vfork创建子进程后，父进程阻塞，直到子进程调用exit或者excle</li>
<li>对于内核中过程fork通过调用clone函数，然后clone函数调用do_fork。do_fork中调用copy_process函数先复制task_struct结构体，然后复制其他关于内存，文件，寄存器等信息。fork采用写时拷贝技术，因此子进程和父进程的页表指向相同的页框。但是vfork不需要拷贝页表，因为父进程会一直阻塞，直接使用父进程页表。  <ul>
<li>引自：<a href="https://www.nowcoder.com/discuss/59394" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/59394</a></li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>死锁</p>
<ul>
<li><p>概念：多个进程之间互相等待对方的资源 ，而在得到对方资源之前不释放自己的资源，造成循环等待现象</p>
</li>
<li><p>死锁产生的条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件</p>
</li>
<li><p>防止死锁的办法：资源一次性分配（破坏请求和保持条件）；可剥夺资源（破坏不可剥夺条件）；资源有序分配法（破坏循环等待条件）</p>
</li>
</ul>
</li>
</ol>
<p>#线程</p>
<pre><code>* 线程是调度的基本单位
* 同一个进程内部有多个线程，所有线程共享同一个进程的内存空间
* 线程的依赖关系，同步与互斥
* 线程之间的tid不同，每个线程都有自己独立的栈空间
* 线程调度只需要保存线程栈、寄存器数据和PC即可，比进程切换开销小的多
</code></pre><ol>
<li><p>线程的创建与结束</p>
<ul>
<li>接口：pthread_create(); pthread_self(); pthread_join(); pthread_exit(); pthread_detach()</li>
</ul>
</li>
<li><p>线程同步</p>
<ul>
<li><p>方法：互斥锁，自旋锁，读写锁，条件变量，屏障</p>
</li>
<li><p>互斥锁：最基本的同步形式；用于保护临界区，以保证任何时刻只有一个线程执行其中的代码或者任何时刻只有一个进程在执行其中的代码</p>
<ul>
<li>锁的开销：锁的粒度太粗，就会出现多个线程阻塞等待相同的锁，不能改变并发性；粒度太细，过多的锁开销就会影响系统性能，而且代码变得复杂</li>
</ul>
</li>
<li><p>自旋锁：自旋锁与互斥锁类似，但是不是通过使线程休眠而阻塞，而是在获得锁之前一直处于忙等的阻塞状态</p>
<ul>
<li>适用于锁被持有的时间很短，线程并不希望在重新调度上开销太大</li>
</ul>
</li>
<li><p>读写锁：读写锁也和互斥锁类似，不过读写锁具有更高的并行性；读写锁的分配规则：只要没有线程持有某个读写锁用于写，那么任意数目的线程均可持有该读写锁用于读。仅当没有线程持有某个读写锁用于读或用于写时，才能分配该读写锁用于写</p>
<ul>
<li>适用于读数据比修改数据频繁的地方</li>
</ul>
</li>
<li><p>条件变量：给多个线程提供一个会和的唱错，条件变量通常配合互斥锁一起使用，允许线程以无竞争的方式等待特定条件的发生</p>
<ul>
<li>生产者消费者模型</li>
</ul>
</li>
<li><p>屏障：是用户协调多个线程并行工作的同步机制。允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行，pthread_join就是一种屏障</p>
<ul>
<li>如使用8个线程分解800万个数的排序工作，每个线程用堆排序对100万个数进行排序，主线程调用一个函数对这些结果进行合并</li>
</ul>
</li>
<li><p>参考资料：</p>
<ul>
<li><a href="http://blog.csdn.net/poison_biti/article/details/76665050" target="_blank" rel="noopener">线程同步机制（互斥量，读写锁，自旋锁，条件变量，屏障）</a></li>
<li><a href="http://blog.csdn.net/Linux_ever/article/details/50966989" target="_blank" rel="noopener">linux多线程—–同步机制(互斥量、读写锁、条件变量)</a></li>
<li><a href="http://blog.csdn.net/electrocrazy/article/details/78931704" target="_blank" rel="noopener">Linux线程间同步 —— 5种方式简介</a></li>
<li><a href="http://blog.csdn.net/u012658346/article/details/51188116" target="_blank" rel="noopener">常见锁的区别及适用场景</a></li>
</ul>
</li>
</ul>
</li>
<li><p>线程池</p>
</li>
</ol>
<p>#进程与线程的比较</p>
<ol>
<li><p>进程间相互独立，A进程内的线程在B进程中不可见；而同一进程的各线程共享进程的内存地址空间和资源，独立性小的多</p>
</li>
<li><p>进程间通信IPC；在保证安全的前提下，线程可以直接读写进程数据段进行通信</p>
</li>
<li><p>线程上下文切换比进程上下文切换快的多</p>
</li>
<li><p>多线程操作系统上，进程不是一个可执行的实体</p>
</li>
</ol>
<p>#多进程和多线程</p>
<ul>
<li><p>多进程：数据共享复杂，同步简单；占用内存多，切换复杂；创建销毁复杂，速度慢；编程调试简单；进程间不会相互影响</p>
</li>
<li><p>多线程：共享简单，同步复杂；占用内存少，切换简单；创建销毁简单，速度快；编程调试复杂；一个线程挂掉会导致整个进程挂掉</p>
</li>
<li><p>多进程与多线程的选择</p>
<ul>
<li>频繁创建销毁优先用线程</li>
<li>需要进行大量计算的优先用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
</ul>
</li>
<li><p>参考资料：</p>
<ul>
<li><a href="http://blog.csdn.net/pingd/article/details/17895933" target="_blank" rel="noopener">多线程还是多进程的选择及区别</a></li>
<li><a href="http://blog.csdn.net/hairetz/article/details/4281931" target="_blank" rel="noopener">多线程和多进程的区别（小结）</a></li>
</ul>
</li>
</ul>
<p>#其他</p>
<ol>
<li><p>判断大小端 </p>
<pre><code>union un{
    int i;  
    char ch;  
};
void fun(){
    union un test;
    test.i = 1;
    if(ch == 1)
        cout &lt;&lt; &quot;小端&quot; &lt;&lt; endl;
    else
        cout &lt;&lt; &quot;大端&quot; &lt;&lt; endl;
}
</code></pre><ul>
<li><p>大端：高位字节放在内存的低地址端，低位字节放在内存的高地址端<br>小端：低位字节放在内存的低地址端，高位字节放在内存的高地址端 </p>
</li>
<li><p>大端：符号位的判定固定为第一个字节，容易判断正负<br>小端：强制转换数据不需要调整字节内容  </p>
</li>
</ul>
</li>
<li><p>++i 不是原子操作</p>
<ul>
<li>++i 分为三个步骤：<ul>
<li>将数据从内存放在寄存器上</li>
<li>在寄存器上自增</li>
<li>把数据从寄存器上拷贝回内存</li>
</ul>
</li>
</ul>
</li>
<li><p>Linux是如何避免内存碎片的</p>
<ul>
<li><p>伙伴算法，用于管理物理内存，避免内存碎片</p>
</li>
<li><p>高速缓存Slab层用于管理内核分配内存，避免碎片</p>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/code.jpg"
                alt="zuyuxia" />
            
              <p class="site-author-name" itemprop="name">zuyuxia</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zuyuxia" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zuyuxia</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
